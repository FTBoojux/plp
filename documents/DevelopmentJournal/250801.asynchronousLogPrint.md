# 说明

原来Java的sout和Rust的println!都是同步的, 这会导致在高并发的情况下, 日志打印会阻塞线程池中的线程, 影响性能。

The original Java `System.out.println` and Rust's `println!` are synchronous, which can block threads in the thread pool under high concurrency, affecting performance.

## 解决方案

通过引入异步日志打印，将日志打印交给一个独立的线程。服务器中将需要打印的内容交给该线程后立即返回，避免阻塞。

## Solution

By introducing asynchronous log printing, the log printing is handled by a separate thread. The server immediately returns after passing the content to be printed to this thread, avoiding blocking.

### 代码实现(Java)

```java
public enum Fog {
    FOGGER
    ;
    private final BlockingQueue<LogMessage> logQueue = new LinkedBlockingQueue<>();
    private final Thread loggingThread;
    private volatile boolean running = true;
    Fog() {
        loggingThread = new Thread(this::processLogs, "AsyncLoggerThread");
        loggingThread.setDaemon(true);
        loggingThread.start();
    }

    public void log(Object message) {
        try {
            logQueue.put(new LogMessage(message.toString()));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Error adding log message to queue: " + e.getMessage());
        }
    }
    private void processLogs() {
        while (running || !logQueue.isEmpty()) {
            try {
                LogMessage logMessage = logQueue.take();
                // TODO 支持自定义日志输出位置
                System.out.println("ASYNC LOG: " + logMessage);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.err.println("Logging thread interrupted: " + e.getMessage());
            }
        }
    }

    public void shutdown() {
        running = false;
        loggingThread.interrupt();
        try {
            loggingThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
示例：
```java
private void handleRequest(Socket accept) throws IOException {
    HttpRequest request = convertToRequest(lines);
    Fog.FOGGER.log(request);
    MatchResult matchResult = findRequestHandler(request.getPath());
}
```

### 代码实现(Rust)

```rust
pub mod fog{
    use std::sync::{mpsc, Mutex};
    use std::thread;

    static SENDER: Mutex<Option<mpsc::Sender<String>>> = Mutex::new(None);
    pub fn init(){
        let mut sender_guard = SENDER.lock().unwrap();
        if sender_guard.is_none() {
            let (sender, receiver) = mpsc::channel();
            thread::spawn(move||{
                while let Ok(message) = receiver.recv() {
                    println!("{}", message);
                }
            });
            *sender_guard = Some(sender);
        }
    }

    pub fn log(message: String){
        if let Ok(guard) = SENDER.lock(){
            if let Some(sender) = &*guard{
                let _ = sender.send(message);
            }
        }
    }
}
```

示例：
```rust
    fn handle_connection(&self, mut tcp_stream: TcpStream) {
       match self.parse_request(&mut tcp_stream) {
           Ok(request) =>{
               // 使用异步日志打印
               // println!("{} {} {}",request.method,request.path,request.version );
               log(format!("{} {} {}",request.method, request.path, request.version));
               let response = self.route_request(request);
               tcp_stream.write(response.build().as_bytes()).expect("TODO: panic message");
           },
           Err(e) => {
               println!("Error: {}", e);
               tcp_stream.write(b"HTTP/1.1 400 Bad Request \r\n\r\n").ok();
           }
        }
    }
```