## 说明/illustration

原先使用BufferReader读取HTTP请求，但BufferReader.readLine()在处理中文字符时会出现获取的字符串长度不符的情况，导致获取request body时出现异常行为

previously we use the BufferReader to read the HTTP request, but the length of String obtained by BufferReader.readLine() could be different from the Content-Length in request header, and result in error when parse the request body

```java
public class WebClient{
    private void handleRequest(Socket accept) throws IOException {
//        detail omitted
        String rawBody = null;
        if(contentLength > 0){
            byte[] bodyBytes = new byte[contentLength];
            int totalBytes = 0;
            while (totalBytes < contentLength){
                int read = inputStream.read(bodyBytes, totalBytes, contentLength - totalBytes);
                if(read == -1){
                    throw new InvalidRequestBodyException("Unexpected end of stream!");
                }
                totalBytes += read;
            }
            rawBody = new String(bodyBytes, StandardCharsets.UTF_8);
            request.setBody(rawBody);
        }
//        ...
    }
}
```

问题的根源在于 Content-Length 是字节数，而 BufferedReader 读取的是字符数。在 UTF-8 下，汉字通常占 3 个字节，而 Java 的 char 是 2 字节的 UTF-16 码元。如果按照 Content-Length 的字节数去分配 char[] 并用 BufferedReader 读取，实际读到的字符数会少于字节数，导致末尾出现 \u0000 空字符。

When reading an HTTP request body with BufferedReader, a mismatch can occur between the number of characters read and the Content-Length header. Content-Length specifies the number of bytes, while BufferedReader reads characters. In UTF-8, most Chinese characters are encoded as 3 bytes, whereas a Java char is a 2-byte UTF-16 code unit. If you size a char[] buffer using Content-Length and read with BufferedReader, you may read fewer characters than bytes, leaving unused slots that show up as trailing null characters (\u0000) at the end.

## 解决方案/solution

弃用Java的BufferReader，改为手动从inputStream中读取request body

discard the BufferedReader and read request body from the inputStream immediately

```java
public class WebClient{
    private void handleRequest(Socket accept) throws IOException {
//        detail omitted
        String rawBody = null;
        if(contentLength > 0){
            byte[] bodyBytes = new byte[contentLength];
            int totalBytes = 0;
            while (totalBytes < contentLength){
                int read = inputStream.read(bodyBytes, totalBytes, contentLength - totalBytes);
                if(read == -1){
                    throw new InvalidRequestBodyException("Unexpected end of stream!");
                }
                totalBytes += read;
            }
            rawBody = new String(bodyBytes, StandardCharsets.UTF_8);
            request.setBody(rawBody);
        }
//        ...
    }
}            
```
