# Java后端进阶：用实验验证虚拟线程的并发性能

## 1.背景

### 1.1 Java中的传统线程模型

传统的Java线程模型，也被称为平台线程（platform threads），它通过把Java中的线程直接映射为操作系统上的内核线程实现。
这一实现导致了Java中的传统线程模型存在以下不足：

- 1.资源开销
  - 传统线程模型的内存开销大，每个线程需要1~2MB的内存
  - 数量规模小
  - 上下文切换开销大。传统线程调度涉及操作系统用户态和内核态间的切换，系统开销大。
- 2.IO处理效率低下
  - 传统线程遇到IO阻塞场景时，对应的系统线程此时也暂停使用，存在性能浪费

在Java自己的虚拟线程出现以前，Java社区也出现了一些其他的解决方案，比如：
- WebFlux
- RxJava
- Netty

等等

这些解决方案通过`响应式编程(Reactive Programming)`解决Java中的高并发问题，虽然性能高，但代码编写的复杂度也有所增加。

## 2 虚拟线程

为了弥补Java中传统线程模型的不足，Java中引入了`虚拟线程(virtual thread)`。虚拟线程在Java 19 版本作为预览特性推出，在Java 21 版本正式发布。

### 2.1 虚拟线程 vs 传统线程

传统线程就像卡车上的车厢，一辆车只能拉一个车厢（一个系统线程对应一个Java线程），而虚拟线程就像车厢里的货箱，一个车厢里可以装载很多个（多个虚拟线程通过载体线程映射到系统）。

- 1.资源开销
  - 虚拟线程需要的内存开销极小，并且可以在运行时按需要自动伸缩。
  - 可以轻松创建数百万个。
  - 虚拟线程的线程调度由JVM进行，不涉及到用户态和内核态间的切换
- 2.更高的IO处理效率
  - 当一个虚拟线程进入IO阻塞状态时，它可以将占用的系统线程让出给其他虚拟线程使用

### 2.2 虚拟线程的适用场景

由虚拟线程“在IO阻塞态让出占用的系统线程”可以发现，在经常需要等待IO导致CPU和系统资源浪费的IO密集型任务场景下，虚拟线程的引入可以提高CPU资源的利用率，提高系统的吞吐量。

同样，CPU密集型任务的场景就不是虚拟线程的适用场景。在CPU密集型的任务场景下，虚拟线程不仅发挥不了“在IO阻塞态让出占用的系统现场”这一特性，还会因为增加的操作成本导致性能略有下降。

在Oracle帮助中心关于虚拟线程的介绍文章里也有提到:

```text
Virtual threads are not faster threads; they do not run code any faster than platform threads. They exist to provide scale (higher throughput), not speed (lower latency).
```

(翻译：虚拟线程并非更快的线程；他们运行代码不会比平台线程更快。他们存在是为了提供规模(更高的吞吐量)，而不是速度(更低的延迟))

## 3.实验验证虚拟线程的特性

### 3.1 实验目的

本实验主要验证两个论点：

- 虚拟线程可以大幅提高系统的吞吐量
- 虚拟线程并不比传统线程运行的更快

### 3.2 实验准备

本实验准备环境如下：

- 硬件环境
  - 笔记本电脑一台（配置：CPU Intel(R) Core(TM) Ultra 7 155H   1.40 GHz；内存 32.0 GB (31.6 GB 可用)
- 软件环境
  - IDEA（版本：2025.3.1.1）
  - JDK（版本；OpenJDK-23)

### 3.3 实验设计

为了证明在 `3.1 实验目的` 中的观点，我们设计如下实验

### 3.3.1 系统吞吐量

我们通过Thread.sleep(200)操作，来模拟实际场景中的IO阻塞情况。

[//]: # (未完待续)