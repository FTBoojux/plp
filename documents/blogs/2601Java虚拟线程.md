# Java后端进阶：用实验验证虚拟线程的并发性能

## 1.背景

### 1.1 Java中的传统线程模型

传统的Java线程模型，也被称为平台线程（platform threads），它通过把Java中的线程直接映射为操作系统上的内核线程实现。
这一实现导致了Java中的传统线程模型存在以下不足：

- 1.资源开销
  - 传统线程模型的内存开销大，每个线程需要1~2MB的内存
  - 数量规模小
  - 上下文切换开销大。传统线程调度涉及操作系统用户态和内核态间的切换，系统开销大。
- 2.IO处理效率低下
  - 传统线程遇到IO阻塞场景时，对应的系统线程此时也暂停使用，存在性能浪费

在Java自己的虚拟线程出现以前，Java社区也出现了一些其他的解决方案，比如：
- WebFlux
- RxJava
- Netty

等等

这些解决方案通过`响应式编程(Reactive Programming)`解决Java中的高并发问题，虽然性能高，但代码编写的复杂度也有所增加。

## 2 虚拟线程

为了弥补Java中传统线程模型的不足，Java中引入了`虚拟线程(virtual thread)`。虚拟线程在Java 19 版本作为预览特性推出，在Java 21 版本正式发布。

### 2.1 虚拟线程 vs 传统线程

传统线程就像卡车上的车厢，一辆车只能拉一个车厢（一个系统线程对应一个Java线程），而虚拟线程就像车厢里的货箱，一个车厢里可以装载很多个（多个虚拟线程通过载体线程映射到系统线程）。

- 1.资源开销
  - 虚拟线程需要的内存开销极小，并且可以在运行时按需要自动伸缩。
  - 可以轻松创建数百万个。
  - 虚拟线程的线程调度由JVM进行，不涉及到用户态和内核态间的切换
- 2.更高的IO处理效率
  - 当一个虚拟线程进入IO阻塞状态时，它可以将占用的系统线程让出给其他虚拟线程使用

### 2.2 虚拟线程的适用场景

由虚拟线程“在IO阻塞态让出占用的系统线程”可以发现，在经常需要等待IO导致CPU和系统资源浪费的IO密集型任务场景下，虚拟线程的引入可以提高CPU资源的利用率，提高系统的吞吐量。

同样，CPU密集型任务的场景就不是虚拟线程的适用场景。在CPU密集型的任务场景下，虚拟线程不仅发挥不了“在IO阻塞态让出占用的系统线程”这一特性，还会因为增加的操作成本导致性能略有下降。

在Oracle帮助中心关于虚拟线程的介绍文章里也有提到:

```text
Virtual threads are not faster threads; they do not run code any faster than platform threads. They exist to provide scale (higher throughput), not speed (lower latency).
```

(翻译：虚拟线程并非更快的线程；他们运行代码不会比平台线程更快。他们存在是为了提供规模(更高的吞吐量)，而不是速度(更低的延迟))

## 3.实验验证虚拟线程的特性

### 3.1 实验目的

本实验主要验证两个论点：

- 虚拟线程可以大幅提高系统的吞吐量
- 虚拟线程并不比传统线程运行的更快

### 3.2 实验准备

本实验准备环境如下：

- 硬件环境
  - 笔记本电脑一台（配置：CPU Intel(R) Core(TM) Ultra 7 155H   1.40 GHz；内存 32.0 GB (31.6 GB 可用)
- 软件环境
  - IDEA（版本：2025.3.1.1）
  - JDK（版本：OpenJDK-23)
  - Windows 11 操作系统

### 3.3 实验设计

为了证明在 `3.1 实验目的` 中的观点，我们设计如下实验

### 3.3.1 核心代码

首先，验证两个论点的流程总体相同：

- 1.创建一个线程池（传统线程池 / 虚拟线程池）
- 2.选择要执行的任务类型（IO密集型 / CPU密集型）
- 3.提交大量任务到线程池执行
- 4.统计任务执行的总时间

因此，我们可以有如下工具方法：

```java
public class CompareIOThreadPools {
    static int taskCount = 10_000;
    public static void verify(String type, ExecutorService threadPool, Runnable task) {
      // 获取开始时间
      long startTime = System.currentTimeMillis();
      // 提交大量任务
      for (int i = 0; i < taskCount; i++) {
        threadPool.submit(task);
      }
      // 等待所有任务完成
      threadPool.shutdown();
      try {
        if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
          threadPool.shutdownNow();
        }
      } catch (InterruptedException e) {
        threadPool.shutdownNow();
      }
      // 获取结束时间
      long endTime = System.currentTimeMillis();
      // 计算并输出总耗时和平均每个任务耗时
      long total = endTime - startTime;
      float avgTime = total / (float) taskCount;
      System.out.println(type + "线程池总耗时: " + total + " ms, 平均每个任务耗时: " + avgTime + " ms");
    }
}
```
然后，我们可以设计两种任务：

通过`Thread.sleep(200)`模拟IO密集型任务：

```java
// IO密集型任务
class IOIntensiveTask implements Runnable {
    @Override
    public void run() {
        try {
            // 模拟IO密集型任务
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
    }
}
```

通过进行大量数学运算模拟CPU密集型任务：

```java
class CpuIntensiveTask implements Runnable {
  @Override
  public void run() {
    // 模拟CPU密集型任务
    double pi = 0;
    for (int i = 0; i < 20_000_000; i++) {
      if (i % 2 == 0) {
        pi += 1.0 / (2 * i + 1);
      } else {
        pi -= 1.0 / (2 * i + 1);
      }
    }
  }
}

```

### 3.3.2 实验执行

最后，我们可以分别使用传统线程池和虚拟线程池来执行这两种任务：

```java
public class CompareIOThreadPools {
    static int taskCount = 10_000;
    public static void main(String[] args) {
        System.out.println("IO密集型任务测试:");
        // 虚拟线程池
        try (ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor()) {
            verify("虚拟", virtualExecutor, new IOIntensiveTask());
        }
        // 传统线程池
        try (ExecutorService traditionalExecutor = Executors.newFixedThreadPool(200)) {
            verify("传统", traditionalExecutor, new IOIntensiveTask());
        }
        System.out.println("CPU密集型任务测试:");
        // 虚拟线程池
        try (ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor()) {
            verify("虚拟", virtualExecutor, new CpuIntensiveTask());
        }
        // 传统线程池
        try (ExecutorService traditionalExecutor = Executors.newFixedThreadPool(200)) {
            verify("传统", traditionalExecutor, new CpuIntensiveTask());
        }
    }
}
```

### 3.4 实验结果

在我的实验环境下，实验结果如下：

```
IO密集型任务测试:
虚拟线程池总耗时: 257 ms, 平均每个任务耗时: 0.0257 ms
传统线程池总耗时: 10374 ms, 平均每个任务耗时: 1.0374 ms
CPU密集型任务测试:
虚拟线程池总耗时: 23316 ms, 平均每个任务耗时: 2.3316 ms
传统线程池总耗时: 23715 ms, 平均每个任务耗时: 2.3715 ms
```

### 3.5 结果分析

从实验结果可以看出：

- 1.在IO密集型任务场景下，虚拟线程池的性能远远优于传统线程池，总耗时仅为传统线程池的约2.5%。
- 2.在CPU密集型任务场景下，虚拟线程池和传统线程池的性能相差不大，虚拟线程池的总耗时略低于传统线程池，但差距并不显著。

### 3.6 总结
通过本实验，我们验证了以下两个论点：
- 1.虚拟线程可以大幅提高系统的吞吐量，特别是在IO密集型任务场景下。
- 2.虚拟线程并不比传统线程运行的更快，在CPU密集型任务场景下，两者的性能相差不大。